/*!
  * Bootstrap v5.0.2 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
import * as Popper from '@popperjs/core';

const NODE_TEXT = 3; const SelectorEngine = {
  find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter((e) => e.matches(t)), parents(e, t) { const n = []; let i = e.parentNode; for (;i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== 3;)i.matches(t) && n.push(i), i = i.parentNode; return n; }, prev(e, t) { let n = e.previousElementSibling; for (;n;) { if (n.matches(t)) return [n]; n = n.previousElementSibling; } return []; }, next(e, t) { let n = e.nextElementSibling; for (;n;) { if (n.matches(t)) return [n]; n = n.nextElementSibling; } return []; },
}; const MAX_UID = 1e6; const MILLISECONDS_MULTIPLIER = 1e3; const TRANSITION_END = 'transitionend'; const toType = (e) => (e == null ? `${e}` : {}.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase()); const getUID = (e) => { do { e += Math.floor(1e6 * Math.random()); } while (document.getElementById(e)); return e; }; const getSelector = (e) => { let t = e.getAttribute('data-bs-target'); if (!t || t === '#') { let n = e.getAttribute('href'); if (!n || !n.includes('#') && !n.startsWith('.')) return null; n.includes('#') && !n.startsWith('#') && (n = `#${n.split('#')[1]}`), t = n && n !== '#' ? n.trim() : null; } return t; }; const getSelectorFromElement = (e) => { const t = getSelector(e); return t && document.querySelector(t) ? t : null; }; const getElementFromSelector = (e) => { const t = getSelector(e); return t ? document.querySelector(t) : null; }; const getTransitionDurationFromElement = (e) => { if (!e) return 0; let{ transitionDuration: t, transitionDelay: n } = window.getComputedStyle(e); const i = Number.parseFloat(t); const s = Number.parseFloat(n); return i || s ? (t = t.split(',')[0], n = n.split(',')[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(n))) : 0; }; const triggerTransitionEnd = (e) => { e.dispatchEvent(new Event(TRANSITION_END)); }; const isElement = (e) => !(!e || typeof e !== 'object') && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType); const getElement = (e) => (isElement(e) ? e.jquery ? e[0] : e : typeof e === 'string' && e.length > 0 ? SelectorEngine.findOne(e) : null); const typeCheckConfig = (e, t, n) => { Object.keys(n).forEach((i) => { const s = n[i]; const o = t[i]; const r = o && isElement(o) ? 'element' : (a = o) == null ? `${a}` : {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase(); let a; if (!new RegExp(s).test(r)) throw new TypeError(`${e.toUpperCase()}: Option "${i}" provided type "${r}" but expected type "${s}".`); }); }; const isVisible = (e) => !(!isElement(e) || e.getClientRects().length === 0) && getComputedStyle(e).getPropertyValue('visibility') === 'visible'; const isDisabled = (e) => !e || e.nodeType !== Node.ELEMENT_NODE || !!e.classList.contains('disabled') || (void 0 !== e.disabled ? e.disabled : e.hasAttribute('disabled') && e.getAttribute('disabled') !== 'false'); const findShadowRoot = (e) => { if (!document.documentElement.attachShadow) return null; if (typeof e.getRootNode === 'function') { const t = e.getRootNode(); return t instanceof ShadowRoot ? t : null; } return e instanceof ShadowRoot ? e : e.parentNode ? findShadowRoot(e.parentNode) : null; }; const noop = () => {}; const reflow = (e) => e.offsetHeight; const getjQuery = () => { const { jQuery: e } = window; return e && !document.body.hasAttribute('data-bs-no-jquery') ? e : null; }; const DOMContentLoadedCallbacks = []; const onDOMContentLoaded = (e) => { document.readyState === 'loading' ? (DOMContentLoadedCallbacks.length || document.addEventListener('DOMContentLoaded', () => { DOMContentLoadedCallbacks.forEach((e) => e()); }), DOMContentLoadedCallbacks.push(e)) : e(); }; const isRTL = () => document.documentElement.dir === 'rtl'; const defineJQueryPlugin = (e) => { let t; t = () => { const t = getjQuery(); if (t) { const n = e.NAME; const i = t.fn[n]; t.fn[n] = e.jQueryInterface, t.fn[n].Constructor = e, t.fn[n].noConflict = () => (t.fn[n] = i, e.jQueryInterface); } }, document.readyState === 'loading' ? (DOMContentLoadedCallbacks.length || document.addEventListener('DOMContentLoaded', () => { DOMContentLoadedCallbacks.forEach((e) => e()); }), DOMContentLoadedCallbacks.push(t)) : t(); }; const execute = (e) => { typeof e === 'function' && e(); }; const executeAfterTransition = (e, t, n = !0) => { if (!n) return void execute(e); const i = getTransitionDurationFromElement(t) + 5; let s = !1; const o = ({ target: n }) => { n === t && (s = !0, t.removeEventListener(TRANSITION_END, o), execute(e)); }; t.addEventListener(TRANSITION_END, o), setTimeout(() => { s || triggerTransitionEnd(t); }, i); }; const getNextActiveElement = (e, t, n, i) => { let s = e.indexOf(t); if (s === -1) return e[!n && i ? e.length - 1 : 0]; const o = e.length; return s += n ? 1 : -1, i && (s = (s + o) % o), e[Math.max(0, Math.min(s, o - 1))]; }; const namespaceRegex = /[^.]*(?=\..*)\.|.*/; const stripNameRegex = /\..*/; const stripUidRegex = /::\d+$/; const eventRegistry = {}; let uidEvent = 1; const customEvents = { mouseenter: 'mouseover', mouseleave: 'mouseout' }; const customEventsRegex = /^(mouseenter|mouseleave)/i; const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function getUidEvent(e, t) { return t && `${t}::${uidEvent++}` || e.uidEvent || uidEvent++; } function getEvent(e) { const t = getUidEvent(e); return e.uidEvent = t, eventRegistry[t] = eventRegistry[t] || {}, eventRegistry[t]; } function bootstrapHandler(e, t) { return function n(i) { return i.delegateTarget = e, n.oneOff && EventHandler.off(e, i.type, t), t.apply(e, [i]); }; } function bootstrapDelegationHandler(e, t, n) { return function i(s) { const o = e.querySelectorAll(t); for (let{ target: r } = s; r && r !== this; r = r.parentNode) for (let a = o.length; a--;) if (o[a] === r) return s.delegateTarget = r, i.oneOff && EventHandler.off(e, s.type, t, n), n.apply(r, [s]); return null; }; } function findHandler(e, t, n = null) { const i = Object.keys(e); for (let s = 0, o = i.length; s < o; s++) { const o = e[i[s]]; if (o.originalHandler === t && o.delegationSelector === n) return o; } return null; } function normalizeParams(e, t, n) { const i = typeof t === 'string'; const s = i ? n : t; let o = getTypeEvent(e); return nativeEvents.has(o) || (o = e), [i, s, o]; } function addHandler(e, t, n, i, s) { if (typeof t !== 'string' || !e) return; if (n || (n = i, i = null), customEventsRegex.test(t)) { const e = (e) => function (t) { if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t); }; i ? i = e(i) : n = e(n); } const [o, r, a] = normalizeParams(t, n, i); const l = getEvent(e); const c = l[a] || (l[a] = {}); const E = findHandler(c, r, o ? n : null); if (E) return void (E.oneOff = E.oneOff && s); const _ = getUidEvent(r, t.replace(namespaceRegex, '')); const h = o ? bootstrapDelegationHandler(e, n, i) : bootstrapHandler(e, n); h.delegationSelector = o ? n : null, h.originalHandler = r, h.oneOff = s, h.uidEvent = _, c[_] = h, e.addEventListener(a, h, o); } function removeHandler(e, t, n, i, s) { const o = findHandler(t[n], i, s); o && (e.removeEventListener(n, o, Boolean(s)), delete t[n][o.uidEvent]); } function removeNamespacedHandlers(e, t, n, i) { const s = t[n] || {}; Object.keys(s).forEach((o) => { if (o.includes(i)) { const i = s[o]; removeHandler(e, t, n, i.originalHandler, i.delegationSelector); } }); } function getTypeEvent(e) { return e = e.replace(stripNameRegex, ''), customEvents[e] || e; } const EventHandler = {
  on(e, t, n, i) { addHandler(e, t, n, i, !1); }, one(e, t, n, i) { addHandler(e, t, n, i, !0); }, off(e, t, n, i) { if (typeof t !== 'string' || !e) return; const [s, o, r] = normalizeParams(t, n, i); const a = r !== t; const l = getEvent(e); const c = t.startsWith('.'); if (void 0 !== o) { if (!l || !l[r]) return; return void removeHandler(e, l, r, o, s ? n : null); }c && Object.keys(l).forEach((n) => { removeNamespacedHandlers(e, l, n, t.slice(1)); }); const E = l[r] || {}; Object.keys(E).forEach((n) => { const i = n.replace(stripUidRegex, ''); if (!a || t.includes(i)) { const t = E[n]; removeHandler(e, l, r, t.originalHandler, t.delegationSelector); } }); }, trigger(e, t, n) { if (typeof t !== 'string' || !e) return null; const i = getjQuery(); const s = getTypeEvent(t); const o = t !== s; const r = nativeEvents.has(s); let a; let l = !0; let c = !0; let E = !1; let _ = null; return o && i && (a = i.Event(t, n), i(e).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), E = a.isDefaultPrevented()), r ? (_ = document.createEvent('HTMLEvents'), _.initEvent(s, l, !0)) : _ = new CustomEvent(t, { bubbles: l, cancelable: !0 }), void 0 !== n && Object.keys(n).forEach((e) => { Object.defineProperty(_, e, { get: () => n[e] }); }), E && _.preventDefault(), c && e.dispatchEvent(_), _.defaultPrevented && void 0 !== a && a.preventDefault(), _; },
}; const elementMap = new Map(); const Data = { set(e, t, n) { elementMap.has(e) || elementMap.set(e, new Map()); const i = elementMap.get(e); i.has(t) || i.size === 0 ? i.set(t, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(i.keys())[0]}.`); }, get: (e, t) => elementMap.has(e) && elementMap.get(e).get(t) || null, remove(e, t) { if (!elementMap.has(e)) return; const n = elementMap.get(e); n.delete(t), n.size === 0 && elementMap.delete(e); } }; const VERSION = '5.0.2'; class BaseComponent {
  constructor(e) { (e = getElement(e)) && (this._element = e, Data.set(this._element, this.constructor.DATA_KEY, this)); }

  dispose() { Data.remove(this._element, this.constructor.DATA_KEY), EventHandler.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((e) => { this[e] = null; }); }

  _queueCallback(e, t, n = !0) { executeAfterTransition(e, t, n); }

  static getInstance(e) { return Data.get(e, this.DATA_KEY); }

  static getOrCreateInstance(e, t = {}) { return this.getInstance(e) || new this(e, typeof t === 'object' ? t : null); }

  static get VERSION() { return '5.0.2'; }

  static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!'); }

  static get DATA_KEY() { return `bs.${this.NAME}`; }

  static get EVENT_KEY() { return `.${this.DATA_KEY}`; }
} const NAME$c = 'alert'; const DATA_KEY$b = 'bs.alert'; const EVENT_KEY$b = '.bs.alert'; const DATA_API_KEY$8 = '.data-api'; const SELECTOR_DISMISS = '[data-bs-dismiss="alert"]'; const EVENT_CLOSE = 'close.bs.alert'; const EVENT_CLOSED = 'closed.bs.alert'; const EVENT_CLICK_DATA_API$7 = 'click.bs.alert.data-api'; const CLASS_NAME_ALERT = 'alert'; const CLASS_NAME_FADE$6 = 'fade'; const CLASS_NAME_SHOW$9 = 'show'; class Alert extends BaseComponent {
  static get NAME() { return NAME$c; }

  close(e) { const t = e ? this._getRootElement(e) : this._element; const n = this._triggerCloseEvent(t); n === null || n.defaultPrevented || this._removeElement(t); }

  _getRootElement(e) { return getElementFromSelector(e) || e.closest('.alert'); }

  _triggerCloseEvent(e) { return EventHandler.trigger(e, EVENT_CLOSE); }

  _removeElement(e) { e.classList.remove('show'); const t = e.classList.contains('fade'); this._queueCallback(() => this._destroyElement(e), e, t); }

  _destroyElement(e) { e.remove(), EventHandler.trigger(e, EVENT_CLOSED); }

  static jQueryInterface(e) { return this.each((function () { const t = Alert.getOrCreateInstance(this); e === 'close' && t[e](this); })); }

  static handleDismiss(e) { return function (t) { t && t.preventDefault(), e.close(this); }; }
}EventHandler.on(document, EVENT_CLICK_DATA_API$7, SELECTOR_DISMISS, Alert.handleDismiss(new Alert())), defineJQueryPlugin(Alert); const NAME$b = 'button'; const DATA_KEY$a = 'bs.button'; const EVENT_KEY$a = '.bs.button'; const DATA_API_KEY$7 = '.data-api'; const CLASS_NAME_ACTIVE$3 = 'active'; const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]'; const EVENT_CLICK_DATA_API$6 = 'click.bs.button.data-api'; class Button extends BaseComponent {
  static get NAME() { return NAME$b; }

  toggle() { this._element.setAttribute('aria-pressed', this._element.classList.toggle('active')); }

  static jQueryInterface(e) { return this.each((function () { const t = Button.getOrCreateInstance(this); e === 'toggle' && t[e](); })); }
} function normalizeData(e) { return e === 'true' || e !== 'false' && (e === Number(e).toString() ? Number(e) : e === '' || e === 'null' ? null : e); } function normalizeDataKey(e) { return e.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`); }EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (e) => { e.preventDefault(); const t = e.target.closest(SELECTOR_DATA_TOGGLE$5); Button.getOrCreateInstance(t).toggle(); }), defineJQueryPlugin(Button); const Manipulator = {
  setDataAttribute(e, t, n) { e.setAttribute(`data-bs-${normalizeDataKey(t)}`, n); }, removeDataAttribute(e, t) { e.removeAttribute(`data-bs-${normalizeDataKey(t)}`); }, getDataAttributes(e) { if (!e) return {}; const t = {}; return Object.keys(e.dataset).filter((e) => e.startsWith('bs')).forEach((n) => { let i = n.replace(/^bs/, ''); i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = normalizeData(e.dataset[n]); }), t; }, getDataAttribute: (e, t) => normalizeData(e.getAttribute(`data-bs-${normalizeDataKey(t)}`)), offset(e) { const t = e.getBoundingClientRect(); return { top: t.top + document.body.scrollTop, left: t.left + document.body.scrollLeft }; }, position: (e) => ({ top: e.offsetTop, left: e.offsetLeft }),
}; const NAME$a = 'carousel'; const DATA_KEY$9 = 'bs.carousel'; const EVENT_KEY$9 = '.bs.carousel'; const DATA_API_KEY$6 = '.data-api'; const ARROW_LEFT_KEY = 'ArrowLeft'; const ARROW_RIGHT_KEY = 'ArrowRight'; const TOUCHEVENT_COMPAT_WAIT = 500; const SWIPE_THRESHOLD = 40; const Default$9 = {
  interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0, touch: !0,
}; const DefaultType$9 = {
  interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean', touch: 'boolean',
}; const ORDER_NEXT = 'next'; const ORDER_PREV = 'prev'; const DIRECTION_LEFT = 'left'; const DIRECTION_RIGHT = 'right'; const KEY_TO_DIRECTION = { ArrowLeft: DIRECTION_RIGHT, ArrowRight: DIRECTION_LEFT }; const EVENT_SLIDE = 'slide.bs.carousel'; const EVENT_SLID = 'slid.bs.carousel'; const EVENT_KEYDOWN = 'keydown.bs.carousel'; const EVENT_MOUSEENTER = 'mouseenter.bs.carousel'; const EVENT_MOUSELEAVE = 'mouseleave.bs.carousel'; const EVENT_TOUCHSTART = 'touchstart.bs.carousel'; const EVENT_TOUCHMOVE = 'touchmove.bs.carousel'; const EVENT_TOUCHEND = 'touchend.bs.carousel'; const EVENT_POINTERDOWN = 'pointerdown.bs.carousel'; const EVENT_POINTERUP = 'pointerup.bs.carousel'; const EVENT_DRAG_START = 'dragstart.bs.carousel'; const EVENT_LOAD_DATA_API$2 = 'load.bs.carousel.data-api'; const EVENT_CLICK_DATA_API$5 = 'click.bs.carousel.data-api'; const CLASS_NAME_CAROUSEL = 'carousel'; const CLASS_NAME_ACTIVE$2 = 'active'; const CLASS_NAME_SLIDE = 'slide'; const CLASS_NAME_END = 'carousel-item-end'; const CLASS_NAME_START = 'carousel-item-start'; const CLASS_NAME_NEXT = 'carousel-item-next'; const CLASS_NAME_PREV = 'carousel-item-prev'; const CLASS_NAME_POINTER_EVENT = 'pointer-event'; const SELECTOR_ACTIVE$1 = '.active'; const SELECTOR_ACTIVE_ITEM = '.active.carousel-item'; const SELECTOR_ITEM = '.carousel-item'; const SELECTOR_ITEM_IMG = '.carousel-item img'; const SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev'; const SELECTOR_INDICATORS = '.carousel-indicators'; const SELECTOR_INDICATOR = '[data-bs-target]'; const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]'; const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]'; const POINTER_TYPE_TOUCH = 'touch'; const POINTER_TYPE_PEN = 'pen'; class Carousel extends BaseComponent {
  constructor(e, t) { super(e), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(t), this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element), this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners(); }

  static get Default() { return Default$9; }

  static get NAME() { return NAME$a; }

  next() { this._slide(ORDER_NEXT); }

  nextWhenVisible() { !document.hidden && isVisible(this._element) && this.next(); }

  prev() { this._slide(ORDER_PREV); }

  pause(e) { e || (this._isPaused = !0), SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element) && (triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null; }

  cycle(e) { e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)); }

  to(e) { this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element); const t = this._getItemIndex(this._activeElement); if (e > this._items.length - 1 || e < 0) return; if (this._isSliding) return void EventHandler.one(this._element, EVENT_SLID, () => this.to(e)); if (t === e) return this.pause(), void this.cycle(); const n = e > t ? ORDER_NEXT : ORDER_PREV; this._slide(n, this._items[e]); }

  _getConfig(e) { return e = { ...Default$9, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' ? e : {} }, typeCheckConfig(NAME$a, e, DefaultType$9), e; }

  _handleSwipe() { const e = Math.abs(this.touchDeltaX); if (e <= 40) return; const t = e / this.touchDeltaX; this.touchDeltaX = 0, t && this._slide(t > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT); }

  _addEventListeners() { this._config.keyboard && EventHandler.on(this._element, EVENT_KEYDOWN, (e) => this._keydown(e)), this._config.pause === 'hover' && (EventHandler.on(this._element, EVENT_MOUSEENTER, (e) => this.pause(e)), EventHandler.on(this._element, EVENT_MOUSELEAVE, (e) => this.cycle(e))), this._config.touch && this._touchSupported && this._addTouchEventListeners(); }

  _addTouchEventListeners() { const e = (e) => { !this._pointerEvent || e.pointerType !== 'pen' && e.pointerType !== 'touch' ? this._pointerEvent || (this.touchStartX = e.touches[0].clientX) : this.touchStartX = e.clientX; }; const t = (e) => { this.touchDeltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this.touchStartX; }; const n = (e) => { !this._pointerEvent || e.pointerType !== 'pen' && e.pointerType !== 'touch' || (this.touchDeltaX = e.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((e) => this.cycle(e), 500 + this._config.interval)); }; SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach((e) => { EventHandler.on(e, EVENT_DRAG_START, (e) => e.preventDefault()); }), this._pointerEvent ? (EventHandler.on(this._element, EVENT_POINTERDOWN, (t) => e(t)), EventHandler.on(this._element, EVENT_POINTERUP, (e) => n(e)), this._element.classList.add('pointer-event')) : (EventHandler.on(this._element, EVENT_TOUCHSTART, (t) => e(t)), EventHandler.on(this._element, EVENT_TOUCHMOVE, (e) => t(e)), EventHandler.on(this._element, EVENT_TOUCHEND, (e) => n(e))); }

  _keydown(e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = KEY_TO_DIRECTION[e.key]; t && (e.preventDefault(), this._slide(t)); }

  _getItemIndex(e) { return this._items = e && e.parentNode ? SelectorEngine.find(SELECTOR_ITEM, e.parentNode) : [], this._items.indexOf(e); }

  _getItemByOrder(e, t) { const n = e === ORDER_NEXT; return getNextActiveElement(this._items, t, n, this._config.wrap); }

  _triggerSlideEvent(e, t) {
    const n = this._getItemIndex(e); const i = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)); return EventHandler.trigger(this._element, EVENT_SLIDE, {
      relatedTarget: e, direction: t, from: i, to: n,
    });
  }

  _setActiveIndicatorElement(e) { if (this._indicatorsElement) { const t = SelectorEngine.findOne('.active', this._indicatorsElement); t.classList.remove('active'), t.removeAttribute('aria-current'); const n = SelectorEngine.find('[data-bs-target]', this._indicatorsElement); for (let t = 0; t < n.length; t++) if (Number.parseInt(n[t].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(e)) { n[t].classList.add('active'), n[t].setAttribute('aria-current', 'true'); break; } } }

  _updateInterval() { const e = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element); if (!e) return; const t = Number.parseInt(e.getAttribute('data-bs-interval'), 10); t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval; }

  _slide(e, t) {
    const n = this._directionToOrder(e); const i = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element); const s = this._getItemIndex(i); const o = t || this._getItemByOrder(n, i); const r = this._getItemIndex(o); const a = Boolean(this._interval); const l = n === ORDER_NEXT; const c = l ? CLASS_NAME_START : CLASS_NAME_END; const E = l ? CLASS_NAME_NEXT : CLASS_NAME_PREV; const _ = this._orderToDirection(n); if (o && o.classList.contains('active')) return void (this._isSliding = !1); if (this._isSliding) return; if (this._triggerSlideEvent(o, _).defaultPrevented) return; if (!i || !o) return; this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o; const h = () => {
      EventHandler.trigger(this._element, EVENT_SLID, {
        relatedTarget: o, direction: _, from: s, to: r,
      });
    }; if (this._element.classList.contains('slide')) { o.classList.add(E), reflow(o), i.classList.add(c), o.classList.add(c); const e = () => { o.classList.remove(c, E), o.classList.add('active'), i.classList.remove('active', E, c), this._isSliding = !1, setTimeout(h, 0); }; this._queueCallback(e, i, !0); } else i.classList.remove('active'), o.classList.add('active'), this._isSliding = !1, h(); a && this.cycle();
  }

  _directionToOrder(e) { return [DIRECTION_RIGHT, DIRECTION_LEFT].includes(e) ? isRTL() ? e === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT : e === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV : e; }

  _orderToDirection(e) { return [ORDER_NEXT, ORDER_PREV].includes(e) ? isRTL() ? e === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT : e === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT : e; }

  static carouselInterface(e, t) { const n = Carousel.getOrCreateInstance(e, t); let{ _config: i } = n; typeof t === 'object' && (i = { ...i, ...t }); const s = typeof t === 'string' ? t : i.slide; if (typeof t === 'number')n.to(t); else if (typeof s === 'string') { if (void 0 === n[s]) throw new TypeError(`No method named "${s}"`); n[s](); } else i.interval && i.ride && (n.pause(), n.cycle()); }

  static jQueryInterface(e) { return this.each((function () { Carousel.carouselInterface(this, e); })); }

  static dataApiClickHandler(e) { const t = getElementFromSelector(this); if (!t || !t.classList.contains('carousel')) return; const n = { ...Manipulator.getDataAttributes(t), ...Manipulator.getDataAttributes(this) }; const i = this.getAttribute('data-bs-slide-to'); i && (n.interval = !1), Carousel.carouselInterface(t, n), i && Carousel.getInstance(t).to(i), e.preventDefault(); }
}EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler), EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => { const e = SelectorEngine.find(SELECTOR_DATA_RIDE); for (let t = 0, n = e.length; t < n; t++)Carousel.carouselInterface(e[t], Carousel.getInstance(e[t])); }), defineJQueryPlugin(Carousel); const NAME$9 = 'collapse'; const DATA_KEY$8 = 'bs.collapse'; const EVENT_KEY$8 = '.bs.collapse'; const DATA_API_KEY$5 = '.data-api'; const Default$8 = { toggle: !0, parent: '' }; const DefaultType$8 = { toggle: 'boolean', parent: '(string|element)' }; const EVENT_SHOW$5 = 'show.bs.collapse'; const EVENT_SHOWN$5 = 'shown.bs.collapse'; const EVENT_HIDE$5 = 'hide.bs.collapse'; const EVENT_HIDDEN$5 = 'hidden.bs.collapse'; const EVENT_CLICK_DATA_API$4 = 'click.bs.collapse.data-api'; const CLASS_NAME_SHOW$8 = 'show'; const CLASS_NAME_COLLAPSE = 'collapse'; const CLASS_NAME_COLLAPSING = 'collapsing'; const CLASS_NAME_COLLAPSED = 'collapsed'; const WIDTH = 'width'; const HEIGHT = 'height'; const SELECTOR_ACTIVES = '.show, .collapsing'; const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]'; class Collapse extends BaseComponent {
  constructor(e, t) { super(e), this._isTransitioning = !1, this._config = this._getConfig(t), this._triggerArray = SelectorEngine.find(`${SELECTOR_DATA_TOGGLE$4}[href="#${this._element.id}"],${SELECTOR_DATA_TOGGLE$4}[data-bs-target="#${this._element.id}"]`); const n = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4); for (let e = 0, t = n.length; e < t; e++) { const t = n[e]; const i = getSelectorFromElement(t); const s = SelectorEngine.find(i).filter((e) => e === this._element); i !== null && s.length && (this._selector = i, this._triggerArray.push(t)); } this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle(); }

  static get Default() { return Default$8; }

  static get NAME() { return NAME$9; }

  toggle() { this._element.classList.contains('show') ? this.hide() : this.show(); }

  show() { if (this._isTransitioning || this._element.classList.contains('show')) return; let e; let t; this._parent && (e = SelectorEngine.find(SELECTOR_ACTIVES, this._parent).filter((e) => (typeof this._config.parent === 'string' ? e.getAttribute('data-bs-parent') === this._config.parent : e.classList.contains('collapse'))), e.length === 0 && (e = null)); const n = SelectorEngine.findOne(this._selector); if (e) { const i = e.find((e) => n !== e); if (t = i ? Collapse.getInstance(i) : null, t && t._isTransitioning) return; } if (EventHandler.trigger(this._element, EVENT_SHOW$5).defaultPrevented) return; e && e.forEach((e) => { n !== e && Collapse.collapseInterface(e, 'hide'), t || Data.set(e, DATA_KEY$8, null); }); const i = this._getDimension(); this._element.classList.remove('collapse'), this._element.classList.add('collapsing'), this._element.style[i] = 0, this._triggerArray.length && this._triggerArray.forEach((e) => { e.classList.remove('collapsed'), e.setAttribute('aria-expanded', !0); }), this.setTransitioning(!0); const s = `scroll${i[0].toUpperCase() + i.slice(1)}`; this._queueCallback(() => { this._element.classList.remove('collapsing'), this._element.classList.add('collapse', 'show'), this._element.style[i] = '', this.setTransitioning(!1), EventHandler.trigger(this._element, EVENT_SHOWN$5); }, this._element, !0), this._element.style[i] = `${this._element[s]}px`; }

  hide() { if (this._isTransitioning || !this._element.classList.contains('show')) return; if (EventHandler.trigger(this._element, EVENT_HIDE$5).defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, reflow(this._element), this._element.classList.add('collapsing'), this._element.classList.remove('collapse', 'show'); const t = this._triggerArray.length; if (t > 0) for (let e = 0; e < t; e++) { const t = this._triggerArray[e]; const n = getElementFromSelector(t); n && !n.classList.contains('show') && (t.classList.add('collapsed'), t.setAttribute('aria-expanded', !1)); } this.setTransitioning(!0), this._element.style[e] = '', this._queueCallback(() => { this.setTransitioning(!1), this._element.classList.remove('collapsing'), this._element.classList.add('collapse'), EventHandler.trigger(this._element, EVENT_HIDDEN$5); }, this._element, !0); }

  setTransitioning(e) { this._isTransitioning = e; }

  _getConfig(e) { return (e = { ...Default$8, ...e }).toggle = Boolean(e.toggle), typeCheckConfig(NAME$9, e, DefaultType$8), e; }

  _getDimension() { return this._element.classList.contains(WIDTH) ? WIDTH : HEIGHT; }

  _getParent() { let{ parent: e } = this._config; e = getElement(e); const t = `${SELECTOR_DATA_TOGGLE$4}[data-bs-parent="${e}"]`; return SelectorEngine.find(t, e).forEach((e) => { const t = getElementFromSelector(e); this._addAriaAndCollapsedClass(t, [e]); }), e; }

  _addAriaAndCollapsedClass(e, t) { if (!e || !t.length) return; const n = e.classList.contains('show'); t.forEach((e) => { n ? e.classList.remove('collapsed') : e.classList.add('collapsed'), e.setAttribute('aria-expanded', n); }); }

  static collapseInterface(e, t) { let n = Collapse.getInstance(e); const i = { ...Default$8, ...Manipulator.getDataAttributes(e), ...typeof t === 'object' && t ? t : {} }; if (!n && i.toggle && typeof t === 'string' && /show|hide/.test(t) && (i.toggle = !1), n || (n = new Collapse(e, i)), typeof t === 'string') { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t](); } }

  static jQueryInterface(e) { return this.each((function () { Collapse.collapseInterface(this, e); })); }
}EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, (function (e) { (e.target.tagName === 'A' || e.delegateTarget && e.delegateTarget.tagName === 'A') && e.preventDefault(); const t = Manipulator.getDataAttributes(this); const n = getSelectorFromElement(this); SelectorEngine.find(n).forEach((e) => { const n = Collapse.getInstance(e); let i; n ? (n._parent === null && typeof t.parent === 'string' && (n._config.parent = t.parent, n._parent = n._getParent()), i = 'toggle') : i = t, Collapse.collapseInterface(e, i); }); })), defineJQueryPlugin(Collapse); const NAME$8 = 'dropdown'; const DATA_KEY$7 = 'bs.dropdown'; const EVENT_KEY$7 = '.bs.dropdown'; const DATA_API_KEY$4 = '.data-api'; const ESCAPE_KEY$2 = 'Escape'; const SPACE_KEY = 'Space'; const TAB_KEY = 'Tab'; const ARROW_UP_KEY = 'ArrowUp'; const ARROW_DOWN_KEY = 'ArrowDown'; const RIGHT_MOUSE_BUTTON = 2; const REGEXP_KEYDOWN = new RegExp('ArrowUp|ArrowDown|Escape'); const EVENT_HIDE$4 = 'hide.bs.dropdown'; const EVENT_HIDDEN$4 = 'hidden.bs.dropdown'; const EVENT_SHOW$4 = 'show.bs.dropdown'; const EVENT_SHOWN$4 = 'shown.bs.dropdown'; const EVENT_CLICK = 'click.bs.dropdown'; const EVENT_CLICK_DATA_API$3 = 'click.bs.dropdown.data-api'; const EVENT_KEYDOWN_DATA_API = 'keydown.bs.dropdown.data-api'; const EVENT_KEYUP_DATA_API = 'keyup.bs.dropdown.data-api'; const CLASS_NAME_SHOW$7 = 'show'; const CLASS_NAME_DROPUP = 'dropup'; const CLASS_NAME_DROPEND = 'dropend'; const CLASS_NAME_DROPSTART = 'dropstart'; const CLASS_NAME_NAVBAR = 'navbar'; const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]'; const SELECTOR_MENU = '.dropdown-menu'; const SELECTOR_NAVBAR_NAV = '.navbar-nav'; const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'; const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start'; const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end'; const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start'; const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end'; const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start'; const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start'; const Default$7 = {
  offset: [0, 2], boundary: 'clippingParents', reference: 'toggle', display: 'dynamic', popperConfig: null, autoClose: !0,
}; const DefaultType$7 = {
  offset: '(array|string|function)', boundary: '(string|element)', reference: '(string|element|object)', display: 'string', popperConfig: '(null|object|function)', autoClose: '(boolean|string)',
}; class Dropdown extends BaseComponent {
  constructor(e, t) { super(e), this._popper = null, this._config = this._getConfig(t), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners(); }

  static get Default() { return Default$7; }

  static get DefaultType() { return DefaultType$7; }

  static get NAME() { return NAME$8; }

  toggle() { isDisabled(this._element) || (this._element.classList.contains('show') ? this.hide() : this.show()); }

  show() { if (isDisabled(this._element) || this._menu.classList.contains('show')) return; const e = Dropdown.getParentFromElement(this._element); const t = { relatedTarget: this._element }; if (!EventHandler.trigger(this._element, EVENT_SHOW$4, t).defaultPrevented) { if (this._inNavbar)Manipulator.setDataAttribute(this._menu, 'popper', 'none'); else { if (void 0 === Popper) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let t = this._element; this._config.reference === 'parent' ? t = e : isElement(this._config.reference) ? t = getElement(this._config.reference) : typeof this._config.reference === 'object' && (t = this._config.reference); const n = this._getPopperConfig(); const i = n.modifiers.find((e) => e.name === 'applyStyles' && !1 === e.enabled); this._popper = Popper.createPopper(t, this._menu, n), i && Manipulator.setDataAttribute(this._menu, 'popper', 'static'); }'ontouchstart' in document.documentElement && !e.closest('.navbar-nav') && [].concat(...document.body.children).forEach((e) => EventHandler.on(e, 'mouseover', noop)), this._element.focus(), this._element.setAttribute('aria-expanded', !0), this._menu.classList.toggle('show'), this._element.classList.toggle('show'), EventHandler.trigger(this._element, EVENT_SHOWN$4, t); } }

  hide() { if (isDisabled(this._element) || !this._menu.classList.contains('show')) return; const e = { relatedTarget: this._element }; this._completeHide(e); }

  dispose() { this._popper && this._popper.destroy(), super.dispose(); }

  update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update(); }

  _addEventListeners() { EventHandler.on(this._element, EVENT_CLICK, (e) => { e.preventDefault(), this.toggle(); }); }

  _completeHide(e) { EventHandler.trigger(this._element, EVENT_HIDE$4, e).defaultPrevented || ('ontouchstart' in document.documentElement && [].concat(...document.body.children).forEach((e) => EventHandler.off(e, 'mouseover', noop)), this._popper && this._popper.destroy(), this._menu.classList.remove('show'), this._element.classList.remove('show'), this._element.setAttribute('aria-expanded', 'false'), Manipulator.removeDataAttribute(this._menu, 'popper'), EventHandler.trigger(this._element, EVENT_HIDDEN$4, e)); }

  _getConfig(e) { if (e = { ...this.constructor.Default, ...Manipulator.getDataAttributes(this._element), ...e }, typeCheckConfig(NAME$8, e, this.constructor.DefaultType), typeof e.reference === 'object' && !isElement(e.reference) && typeof e.reference.getBoundingClientRect !== 'function') throw new TypeError(`${NAME$8.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e; }

  _getMenuElement() { return SelectorEngine.next(this._element, SELECTOR_MENU)[0]; }

  _getPlacement() { const e = this._element.parentNode; if (e.classList.contains('dropend')) return PLACEMENT_RIGHT; if (e.classList.contains('dropstart')) return PLACEMENT_LEFT; const t = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end'; return e.classList.contains('dropup') ? t ? PLACEMENT_TOPEND : PLACEMENT_TOP : t ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM; }

  _detectNavbar() { return this._element.closest('.navbar') !== null; }

  _getOffset() { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map((e) => Number.parseInt(e, 10)) : typeof e === 'function' ? (t) => e(t, this._element) : e; }

  _getPopperConfig() { const e = { placement: this._getPlacement(), modifiers: [{ name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'offset', options: { offset: this._getOffset() } }] }; return this._config.display === 'static' && (e.modifiers = [{ name: 'applyStyles', enabled: !1 }]), { ...e, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(e) : this._config.popperConfig }; }

  _selectMenuItem({ key: e, target: t }) { const n = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible); n.length && getNextActiveElement(n, t, e === 'ArrowDown', !n.includes(t)).focus(); }

  static dropdownInterface(e, t) { const n = Dropdown.getOrCreateInstance(e, t); if (typeof t === 'string') { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t](); } }

  static jQueryInterface(e) { return this.each((function () { Dropdown.dropdownInterface(this, e); })); }

  static clearMenus(e) { if (e && (e.button === 2 || e.type === 'keyup' && e.key !== 'Tab')) return; const t = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3); for (let n = 0, i = t.length; n < i; n++) { const i = Dropdown.getInstance(t[n]); if (!i || !1 === i._config.autoClose) continue; if (!i._element.classList.contains('show')) continue; const s = { relatedTarget: i._element }; if (e) { const t = e.composedPath(); const n = t.includes(i._menu); if (t.includes(i._element) || i._config.autoClose === 'inside' && !n || i._config.autoClose === 'outside' && n) continue; if (i._menu.contains(e.target) && (e.type === 'keyup' && e.key === 'Tab' || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; e.type === 'click' && (s.clickEvent = e); }i._completeHide(s); } }

  static getParentFromElement(e) { return getElementFromSelector(e) || e.parentNode; }

  static dataApiKeydownHandler(e) { if (/input|textarea/i.test(e.target.tagName) ? e.key === 'Space' || e.key !== 'Escape' && (e.key !== 'ArrowDown' && e.key !== 'ArrowUp' || e.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(e.key)) return; const t = this.classList.contains('show'); if (!t && e.key === 'Escape') return; if (e.preventDefault(), e.stopPropagation(), isDisabled(this)) return; const n = () => (this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0]); return e.key === 'Escape' ? (n().focus(), void Dropdown.clearMenus()) : e.key === 'ArrowUp' || e.key === 'ArrowDown' ? (t || n().click(), void Dropdown.getInstance(n())._selectMenuItem(e)) : void (t && e.key !== 'Space' || Dropdown.clearMenus()); }
}EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler), EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler), EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus), EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus), EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, (function (e) { e.preventDefault(), Dropdown.dropdownInterface(this); })), defineJQueryPlugin(Dropdown); const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const SELECTOR_STICKY_CONTENT = '.sticky-top'; class ScrollBarHelper {
  constructor() { this._element = document.body; }

  getWidth() { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e); }

  hide() { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, 'paddingRight', (t) => t + e), this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', (t) => t + e), this._setElementAttributes('.sticky-top', 'marginRight', (t) => t - e); }

  _disableOverFlow() { this._saveInitialAttribute(this._element, 'overflow'), this._element.style.overflow = 'hidden'; }

  _setElementAttributes(e, t, n) { const i = this.getWidth(); this._applyManipulationCallback(e, (e) => { if (e !== this._element && window.innerWidth > e.clientWidth + i) return; this._saveInitialAttribute(e, t); const s = window.getComputedStyle(e)[t]; e.style[t] = `${n(Number.parseFloat(s))}px`; }); }

  reset() { this._resetElementAttributes(this._element, 'overflow'), this._resetElementAttributes(this._element, 'paddingRight'), this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight'), this._resetElementAttributes('.sticky-top', 'marginRight'); }

  _saveInitialAttribute(e, t) { const n = e.style[t]; n && Manipulator.setDataAttribute(e, t, n); }

  _resetElementAttributes(e, t) { this._applyManipulationCallback(e, (e) => { const n = Manipulator.getDataAttribute(e, t); void 0 === n ? e.style.removeProperty(t) : (Manipulator.removeDataAttribute(e, t), e.style[t] = n); }); }

  _applyManipulationCallback(e, t) { isElement(e) ? t(e) : SelectorEngine.find(e, this._element).forEach(t); }

  isOverflowing() { return this.getWidth() > 0; }
} const Default$6 = {
  isVisible: !0, isAnimated: !1, rootElement: 'body', clickCallback: null,
}; const DefaultType$6 = {
  isVisible: 'boolean', isAnimated: 'boolean', rootElement: '(element|string)', clickCallback: '(function|null)',
}; const NAME$7 = 'backdrop'; const CLASS_NAME_BACKDROP = 'modal-backdrop'; const CLASS_NAME_FADE$5 = 'fade'; const CLASS_NAME_SHOW$6 = 'show'; const EVENT_MOUSEDOWN = 'mousedown.bs.backdrop'; class Backdrop {
  constructor(e) { this._config = this._getConfig(e), this._isAppended = !1, this._element = null; }

  show(e) { this._config.isVisible ? (this._append(), this._config.isAnimated && reflow(this._getElement()), this._getElement().classList.add('show'), this._emulateAnimation(() => { execute(e); })) : execute(e); }

  hide(e) { this._config.isVisible ? (this._getElement().classList.remove('show'), this._emulateAnimation(() => { this.dispose(), execute(e); })) : execute(e); }

  _getElement() { if (!this._element) { const e = document.createElement('div'); e.className = 'modal-backdrop', this._config.isAnimated && e.classList.add('fade'), this._element = e; } return this._element; }

  _getConfig(e) { return (e = { ...Default$6, ...typeof e === 'object' ? e : {} }).rootElement = getElement(e.rootElement), typeCheckConfig(NAME$7, e, DefaultType$6), e; }

  _append() { this._isAppended || (this._config.rootElement.appendChild(this._getElement()), EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => { execute(this._config.clickCallback); }), this._isAppended = !0); }

  dispose() { this._isAppended && (EventHandler.off(this._element, EVENT_MOUSEDOWN), this._element.remove(), this._isAppended = !1); }

  _emulateAnimation(e) { executeAfterTransition(e, this._getElement(), this._config.isAnimated); }
} const NAME$6 = 'modal'; const DATA_KEY$6 = 'bs.modal'; const EVENT_KEY$6 = '.bs.modal'; const DATA_API_KEY$3 = '.data-api'; const ESCAPE_KEY$1 = 'Escape'; const Default$5 = { backdrop: !0, keyboard: !0, focus: !0 }; const DefaultType$5 = { backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean' }; const EVENT_HIDE$3 = 'hide.bs.modal'; const EVENT_HIDE_PREVENTED = 'hidePrevented.bs.modal'; const EVENT_HIDDEN$3 = 'hidden.bs.modal'; const EVENT_SHOW$3 = 'show.bs.modal'; const EVENT_SHOWN$3 = 'shown.bs.modal'; const EVENT_FOCUSIN$2 = 'focusin.bs.modal'; const EVENT_RESIZE = 'resize.bs.modal'; const EVENT_CLICK_DISMISS$2 = 'click.dismiss.bs.modal'; const EVENT_KEYDOWN_DISMISS$1 = 'keydown.dismiss.bs.modal'; const EVENT_MOUSEUP_DISMISS = 'mouseup.dismiss.bs.modal'; const EVENT_MOUSEDOWN_DISMISS = 'mousedown.dismiss.bs.modal'; const EVENT_CLICK_DATA_API$2 = 'click.bs.modal.data-api'; const CLASS_NAME_OPEN = 'modal-open'; const CLASS_NAME_FADE$4 = 'fade'; const CLASS_NAME_SHOW$5 = 'show'; const CLASS_NAME_STATIC = 'modal-static'; const SELECTOR_DIALOG = '.modal-dialog'; const SELECTOR_MODAL_BODY = '.modal-body'; const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]'; const SELECTOR_DATA_DISMISS$2 = '[data-bs-dismiss="modal"]'; class Modal extends BaseComponent {
  constructor(e, t) { super(e), this._config = this._getConfig(t), this._dialog = SelectorEngine.findOne('.modal-dialog', this._element), this._backdrop = this._initializeBackDrop(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ScrollBarHelper(); }

  static get Default() { return Default$5; }

  static get NAME() { return NAME$6; }

  toggle(e) { return this._isShown ? this.hide() : this.show(e); }

  show(e) { this._isShown || this._isTransitioning || EventHandler.trigger(this._element, EVENT_SHOW$3, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add('modal-open'), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, SELECTOR_DATA_DISMISS$2, (e) => this.hide(e)), EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => { EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, (e) => { e.target === this._element && (this._ignoreBackdropClick = !0); }); }), this._showBackdrop(() => this._showElement(e))); }

  hide(e) { if (e && ['A', 'AREA'].includes(e.target.tagName) && e.preventDefault(), !this._isShown || this._isTransitioning) return; if (EventHandler.trigger(this._element, EVENT_HIDE$3).defaultPrevented) return; this._isShown = !1; const t = this._isAnimated(); t && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), EventHandler.off(document, EVENT_FOCUSIN$2), this._element.classList.remove('show'), EventHandler.off(this._element, EVENT_CLICK_DISMISS$2), EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS), this._queueCallback(() => this._hideModal(), this._element, t); }

  dispose() { [window, this._dialog].forEach((e) => EventHandler.off(e, '.bs.modal')), this._backdrop.dispose(), super.dispose(), EventHandler.off(document, EVENT_FOCUSIN$2); }

  handleUpdate() { this._adjustDialog(); }

  _initializeBackDrop() { return new Backdrop({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }); }

  _getConfig(e) { return e = { ...Default$5, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' ? e : {} }, typeCheckConfig(NAME$6, e, DefaultType$5), e; }

  _showElement(e) { const t = this._isAnimated(); const n = SelectorEngine.findOne('.modal-body', this._dialog); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.scrollTop = 0, n && (n.scrollTop = 0), t && reflow(this._element), this._element.classList.add('show'), this._config.focus && this._enforceFocus(), this._queueCallback(() => { this._config.focus && this._element.focus(), this._isTransitioning = !1, EventHandler.trigger(this._element, EVENT_SHOWN$3, { relatedTarget: e }); }, this._dialog, t); }

  _enforceFocus() { EventHandler.off(document, EVENT_FOCUSIN$2), EventHandler.on(document, EVENT_FOCUSIN$2, (e) => { document === e.target || this._element === e.target || this._element.contains(e.target) || this._element.focus(); }); }

  _setEscapeEvent() { this._isShown ? EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (e) => { this._config.keyboard && e.key === 'Escape' ? (e.preventDefault(), this.hide()) : this._config.keyboard || e.key !== 'Escape' || this._triggerBackdropTransition(); }) : EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1); }

  _setResizeEvent() { this._isShown ? EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog()) : EventHandler.off(window, EVENT_RESIZE); }

  _hideModal() { this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove('modal-open'), this._resetAdjustments(), this._scrollBar.reset(), EventHandler.trigger(this._element, EVENT_HIDDEN$3); }); }

  _showBackdrop(e) { EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, (e) => { this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : e.target === e.currentTarget && (!0 === this._config.backdrop ? this.hide() : this._config.backdrop === 'static' && this._triggerBackdropTransition()); }), this._backdrop.show(e); }

  _isAnimated() { return this._element.classList.contains('fade'); }

  _triggerBackdropTransition() { if (EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED).defaultPrevented) return; const { classList: e, scrollHeight: t, style: n } = this._element; const i = t > document.documentElement.clientHeight; !i && n.overflowY === 'hidden' || e.contains('modal-static') || (i || (n.overflowY = 'hidden'), e.add('modal-static'), this._queueCallback(() => { e.remove('modal-static'), i || this._queueCallback(() => { n.overflowY = ''; }, this._dialog); }, this._dialog), this._element.focus()); }

  _adjustDialog() { const e = this._element.scrollHeight > document.documentElement.clientHeight; const t = this._scrollBar.getWidth(); const n = t > 0; (!n && e && !isRTL() || n && !e && isRTL()) && (this._element.style.paddingLeft = `${t}px`), (n && !e && !isRTL() || !n && e && isRTL()) && (this._element.style.paddingRight = `${t}px`); }

  _resetAdjustments() { this._element.style.paddingLeft = '', this._element.style.paddingRight = ''; }

  static jQueryInterface(e, t) { return this.each((function () { const n = Modal.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === n[e]) throw new TypeError(`No method named "${e}"`); n[e](t); } })); }
}EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, (function (e) { const t = getElementFromSelector(this); ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), EventHandler.one(t, EVENT_SHOW$3, (e) => { e.defaultPrevented || EventHandler.one(t, EVENT_HIDDEN$3, () => { isVisible(this) && this.focus(); }); }), Modal.getOrCreateInstance(t).toggle(this); })), defineJQueryPlugin(Modal); const NAME$5 = 'offcanvas'; const DATA_KEY$5 = 'bs.offcanvas'; const EVENT_KEY$5 = '.bs.offcanvas'; const DATA_API_KEY$2 = '.data-api'; const EVENT_LOAD_DATA_API$1 = 'load.bs.offcanvas.data-api'; const ESCAPE_KEY = 'Escape'; const Default$4 = { backdrop: !0, keyboard: !0, scroll: !1 }; const DefaultType$4 = { backdrop: 'boolean', keyboard: 'boolean', scroll: 'boolean' }; const CLASS_NAME_SHOW$4 = 'show'; const OPEN_SELECTOR = '.offcanvas.show'; const EVENT_SHOW$2 = 'show.bs.offcanvas'; const EVENT_SHOWN$2 = 'shown.bs.offcanvas'; const EVENT_HIDE$2 = 'hide.bs.offcanvas'; const EVENT_HIDDEN$2 = 'hidden.bs.offcanvas'; const EVENT_FOCUSIN$1 = 'focusin.bs.offcanvas'; const EVENT_CLICK_DATA_API$1 = 'click.bs.offcanvas.data-api'; const EVENT_CLICK_DISMISS$1 = 'click.dismiss.bs.offcanvas'; const EVENT_KEYDOWN_DISMISS = 'keydown.dismiss.bs.offcanvas'; const SELECTOR_DATA_DISMISS$1 = '[data-bs-dismiss="offcanvas"]'; const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]'; class Offcanvas extends BaseComponent {
  constructor(e, t) { super(e), this._config = this._getConfig(t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._addEventListeners(); }

  static get NAME() { return NAME$5; }

  static get Default() { return Default$4; }

  toggle(e) { return this._isShown ? this.hide() : this.show(e); }

  show(e) { this._isShown || EventHandler.trigger(this._element, EVENT_SHOW$2, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = 'visible', this._backdrop.show(), this._config.scroll || ((new ScrollBarHelper()).hide(), this._enforceFocusOnElement(this._element)), this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.classList.add('show'), this._queueCallback(() => { EventHandler.trigger(this._element, EVENT_SHOWN$2, { relatedTarget: e }); }, this._element, !0)); }

  hide() { this._isShown && (EventHandler.trigger(this._element, EVENT_HIDE$2).defaultPrevented || (EventHandler.off(document, EVENT_FOCUSIN$1), this._element.blur(), this._isShown = !1, this._element.classList.remove('show'), this._backdrop.hide(), this._queueCallback(() => { this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._element.style.visibility = 'hidden', this._config.scroll || (new ScrollBarHelper()).reset(), EventHandler.trigger(this._element, EVENT_HIDDEN$2); }, this._element, !0))); }

  dispose() { this._backdrop.dispose(), super.dispose(), EventHandler.off(document, EVENT_FOCUSIN$1); }

  _getConfig(e) { return e = { ...Default$4, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' ? e : {} }, typeCheckConfig(NAME$5, e, DefaultType$4), e; }

  _initializeBackDrop() {
    return new Backdrop({
      isVisible: this._config.backdrop, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: () => this.hide(),
    });
  }

  _enforceFocusOnElement(e) { EventHandler.off(document, EVENT_FOCUSIN$1), EventHandler.on(document, EVENT_FOCUSIN$1, (t) => { document === t.target || e === t.target || e.contains(t.target) || e.focus(); }), e.focus(); }

  _addEventListeners() { EventHandler.on(this._element, EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, () => this.hide()), EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (e) => { this._config.keyboard && e.key === 'Escape' && this.hide(); }); }

  static jQueryInterface(e) { return this.each((function () { const t = Offcanvas.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this); } })); }
}EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, (function (e) { const t = getElementFromSelector(this); if (['A', 'AREA'].includes(this.tagName) && e.preventDefault(), isDisabled(this)) return; EventHandler.one(t, EVENT_HIDDEN$2, () => { isVisible(this) && this.focus(); }); const n = SelectorEngine.findOne(OPEN_SELECTOR); n && n !== t && Offcanvas.getInstance(n).hide(), Offcanvas.getOrCreateInstance(t).toggle(this); })), EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => SelectorEngine.find(OPEN_SELECTOR).forEach((e) => Offcanvas.getOrCreateInstance(e).show())), defineJQueryPlugin(Offcanvas); const uriAttrs = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']); const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i; const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i; const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; const allowedAttribute = (e, t) => { const n = e.nodeName.toLowerCase(); if (t.includes(n)) return !uriAttrs.has(n) || Boolean(SAFE_URL_PATTERN.test(e.nodeValue) || DATA_URL_PATTERN.test(e.nodeValue)); const i = t.filter((e) => e instanceof RegExp); for (let e = 0, t = i.length; e < t; e++) if (i[e].test(n)) return !0; return !1; }; const DefaultAllowlist = {
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'srcset', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [],
}; function sanitizeHtml(e, t, n) { if (!e.length) return e; if (n && typeof n === 'function') return n(e); const i = (new window.DOMParser()).parseFromString(e, 'text/html'); const s = Object.keys(t); const o = [].concat(...i.body.querySelectorAll('*')); for (let e = 0, n = o.length; e < n; e++) { const n = o[e]; const i = n.nodeName.toLowerCase(); if (!s.includes(i)) { n.remove(); continue; } const r = [].concat(...n.attributes); const a = [].concat(t['*'] || [], t[i] || []); r.forEach((e) => { allowedAttribute(e, a) || n.removeAttribute(e.nodeName); }); } return i.body.innerHTML; } const NAME$4 = 'tooltip'; const DATA_KEY$4 = 'bs.tooltip'; const EVENT_KEY$4 = '.bs.tooltip'; const CLASS_PREFIX$1 = 'bs-tooltip'; const BSCLS_PREFIX_REGEX$1 = new RegExp('(^|\\s)bs-tooltip\\S+', 'g'); const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']); const DefaultType$3 = {
  animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(array|string|function)', container: '(string|element|boolean)', fallbackPlacements: 'array', boundary: '(string|element)', customClass: '(string|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', allowList: 'object', popperConfig: '(null|object|function)',
}; const AttachmentMap = {
  AUTO: 'auto', TOP: 'top', RIGHT: isRTL() ? 'left' : 'right', BOTTOM: 'bottom', LEFT: isRTL() ? 'right' : 'left',
}; const Default$3 = {
  animation: !0, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: 'hover focus', title: '', delay: 0, html: !1, selector: !1, placement: 'top', offset: [0, 0], container: !1, fallbackPlacements: ['top', 'right', 'bottom', 'left'], boundary: 'clippingParents', customClass: '', sanitize: !0, sanitizeFn: null, allowList: DefaultAllowlist, popperConfig: null,
}; const Event$2 = {
  HIDE: 'hide.bs.tooltip', HIDDEN: 'hidden.bs.tooltip', SHOW: 'show.bs.tooltip', SHOWN: 'shown.bs.tooltip', INSERTED: 'inserted.bs.tooltip', CLICK: 'click.bs.tooltip', FOCUSIN: 'focusin.bs.tooltip', FOCUSOUT: 'focusout.bs.tooltip', MOUSEENTER: 'mouseenter.bs.tooltip', MOUSELEAVE: 'mouseleave.bs.tooltip',
}; const CLASS_NAME_FADE$3 = 'fade'; const CLASS_NAME_MODAL = 'modal'; const CLASS_NAME_SHOW$3 = 'show'; const HOVER_STATE_SHOW = 'show'; const HOVER_STATE_OUT = 'out'; const SELECTOR_TOOLTIP_INNER = '.tooltip-inner'; const TRIGGER_HOVER = 'hover'; const TRIGGER_FOCUS = 'focus'; const TRIGGER_CLICK = 'click'; const TRIGGER_MANUAL = 'manual'; class Tooltip extends BaseComponent {
  constructor(e, t) { if (void 0 === Popper) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e), this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(t), this.tip = null, this._setListeners(); }

  static get Default() { return Default$3; }

  static get NAME() { return NAME$4; }

  static get Event() { return Event$2; }

  static get DefaultType() { return DefaultType$3; }

  enable() { this._isEnabled = !0; }

  disable() { this._isEnabled = !1; }

  toggleEnabled() { this._isEnabled = !this._isEnabled; }

  toggle(e) { if (this._isEnabled) if (e) { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger.click = !t._activeTrigger.click, t._isWithActiveTrigger() ? t._enter(null, t) : t._leave(null, t); } else { if (this.getTipElement().classList.contains('show')) return void this._leave(null, this); this._enter(null, this); } }

  dispose() { clearTimeout(this._timeout), EventHandler.off(this._element.closest('.modal'), 'hide.bs.modal', this._hideModalHandler), this.tip && this.tip.remove(), this._popper && this._popper.destroy(), super.dispose(); }

  show() { if (this._element.style.display === 'none') throw new Error('Please use show on visible elements'); if (!this.isWithContent() || !this._isEnabled) return; const e = EventHandler.trigger(this._element, this.constructor.Event.SHOW); const t = findShadowRoot(this._element); const n = t === null ? this._element.ownerDocument.documentElement.contains(this._element) : t.contains(this._element); if (e.defaultPrevented || !n) return; const i = this.getTipElement(); const s = getUID(this.constructor.NAME); i.setAttribute('id', s), this._element.setAttribute('aria-describedby', s), this.setContent(), this._config.animation && i.classList.add('fade'); const o = typeof this._config.placement === 'function' ? this._config.placement.call(this, i, this._element) : this._config.placement; const r = this._getAttachment(o); this._addAttachmentClass(r); const { container: a } = this._config; Data.set(i, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (a.appendChild(i), EventHandler.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Popper.createPopper(this._element, i, this._getPopperConfig(r)), i.classList.add('show'); const l = typeof this._config.customClass === 'function' ? this._config.customClass() : this._config.customClass; l && i.classList.add(...l.split(' ')), 'ontouchstart' in document.documentElement && [].concat(...document.body.children).forEach((e) => { EventHandler.on(e, 'mouseover', noop); }); const c = this.tip.classList.contains('fade'); this._queueCallback(() => { const e = this._hoverState; this._hoverState = null, EventHandler.trigger(this._element, this.constructor.Event.SHOWN), e === 'out' && this._leave(null, this); }, this.tip, c); }

  hide() { if (!this._popper) return; const e = this.getTipElement(); if (EventHandler.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return; e.classList.remove('show'), 'ontouchstart' in document.documentElement && [].concat(...document.body.children).forEach((e) => EventHandler.off(e, 'mouseover', noop)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1; const t = this.tip.classList.contains('fade'); this._queueCallback(() => { this._isWithActiveTrigger() || (this._hoverState !== 'show' && e.remove(), this._cleanTipClass(), this._element.removeAttribute('aria-describedby'), EventHandler.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null)); }, this.tip, t), this._hoverState = ''; }

  update() { this._popper !== null && this._popper.update(); }

  isWithContent() { return Boolean(this.getTitle()); }

  getTipElement() { if (this.tip) return this.tip; const e = document.createElement('div'); return e.innerHTML = this._config.template, this.tip = e.children[0], this.tip; }

  setContent() { const e = this.getTipElement(); this.setElementContent(SelectorEngine.findOne('.tooltip-inner', e), this.getTitle()), e.classList.remove('fade', 'show'); }

  setElementContent(e, t) { if (e !== null) return isElement(t) ? (t = getElement(t), void (this._config.html ? t.parentNode !== e && (e.innerHTML = '', e.appendChild(t)) : e.textContent = t.textContent)) : void (this._config.html ? (this._config.sanitize && (t = sanitizeHtml(t, this._config.allowList, this._config.sanitizeFn)), e.innerHTML = t) : e.textContent = t); }

  getTitle() { let e = this._element.getAttribute('data-bs-original-title'); return e || (e = typeof this._config.title === 'function' ? this._config.title.call(this._element) : this._config.title), e; }

  updateAttachment(e) { return e === 'right' ? 'end' : e === 'left' ? 'start' : e; }

  _initializeOnDelegatedTarget(e, t) { const n = this.constructor.DATA_KEY; return (t = t || Data.get(e.delegateTarget, n)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), Data.set(e.delegateTarget, n, t)), t; }

  _getOffset() { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map((e) => Number.parseInt(e, 10)) : typeof e === 'function' ? (t) => e(t, this._element) : e; }

  _getPopperConfig(e) {
    const t = {
      placement: e,
      modifiers: [{ name: 'flip', options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: 'offset', options: { offset: this._getOffset() } }, { name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'arrow', options: { element: `.${this.constructor.NAME}-arrow` } }, {
        name: 'onChange', enabled: !0, phase: 'afterWrite', fn: (e) => this._handlePopperPlacementChange(e),
      }],
      onFirstUpdate: (e) => { e.options.placement !== e.placement && this._handlePopperPlacementChange(e); },
    }; return { ...t, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(t) : this._config.popperConfig };
  }

  _addAttachmentClass(e) { this.getTipElement().classList.add(`bs-tooltip-${this.updateAttachment(e)}`); }

  _getAttachment(e) { return AttachmentMap[e.toUpperCase()]; }

  _setListeners() { this._config.trigger.split(' ').forEach((e) => { if (e === 'click')EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, (e) => this.toggle(e)); else if (e !== 'manual') { const t = e === 'hover' ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN; const n = e === 'hover' ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT; EventHandler.on(this._element, t, this._config.selector, (e) => this._enter(e)), EventHandler.on(this._element, n, this._config.selector, (e) => this._leave(e)); } }), this._hideModalHandler = () => { this._element && this.hide(); }, EventHandler.on(this._element.closest('.modal'), 'hide.bs.modal', this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: 'manual', selector: '' } : this._fixTitle(); }

  _fixTitle() { const e = this._element.getAttribute('title'); const t = typeof this._element.getAttribute('data-bs-original-title'); (e || t !== 'string') && (this._element.setAttribute('data-bs-original-title', e || ''), !e || this._element.getAttribute('aria-label') || this._element.textContent || this._element.setAttribute('aria-label', e), this._element.setAttribute('title', '')); }

  _enter(e, t) { t = this._initializeOnDelegatedTarget(e, t), e && (t._activeTrigger[e.type === 'focusin' ? 'focus' : 'hover'] = !0), t.getTipElement().classList.contains('show') || t._hoverState === 'show' ? t._hoverState = 'show' : (clearTimeout(t._timeout), t._hoverState = 'show', t._config.delay && t._config.delay.show ? t._timeout = setTimeout(() => { t._hoverState === 'show' && t.show(); }, t._config.delay.show) : t.show()); }

  _leave(e, t) { t = this._initializeOnDelegatedTarget(e, t), e && (t._activeTrigger[e.type === 'focusout' ? 'focus' : 'hover'] = t._element.contains(e.relatedTarget)), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = 'out', t._config.delay && t._config.delay.hide ? t._timeout = setTimeout(() => { t._hoverState === 'out' && t.hide(); }, t._config.delay.hide) : t.hide()); }

  _isWithActiveTrigger() { for (const e in this._activeTrigger) if (this._activeTrigger[e]) return !0; return !1; }

  _getConfig(e) { const t = Manipulator.getDataAttributes(this._element); return Object.keys(t).forEach((e) => { DISALLOWED_ATTRIBUTES.has(e) && delete t[e]; }), (e = { ...this.constructor.Default, ...t, ...typeof e === 'object' && e ? e : {} }).container = !1 === e.container ? document.body : getElement(e.container), typeof e.delay === 'number' && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title === 'number' && (e.title = e.title.toString()), typeof e.content === 'number' && (e.content = e.content.toString()), typeCheckConfig(NAME$4, e, this.constructor.DefaultType), e.sanitize && (e.template = sanitizeHtml(e.template, e.allowList, e.sanitizeFn)), e; }

  _getDelegateConfig() { const e = {}; if (this._config) for (const t in this._config) this.constructor.Default[t] !== this._config[t] && (e[t] = this._config[t]); return e; }

  _cleanTipClass() { const e = this.getTipElement(); const t = e.getAttribute('class').match(BSCLS_PREFIX_REGEX$1); t !== null && t.length > 0 && t.map((e) => e.trim()).forEach((t) => e.classList.remove(t)); }

  _handlePopperPlacementChange(e) { const { state: t } = e; t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement))); }

  static jQueryInterface(e) { return this.each((function () { const t = Tooltip.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } })); }
}defineJQueryPlugin(Tooltip); const NAME$3 = 'popover'; const DATA_KEY$3 = 'bs.popover'; const EVENT_KEY$3 = '.bs.popover'; const CLASS_PREFIX = 'bs-popover'; const BSCLS_PREFIX_REGEX = new RegExp('(^|\\s)bs-popover\\S+', 'g'); const Default$2 = {
  ...Tooltip.Default, placement: 'right', offset: [0, 8], trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
}; const DefaultType$2 = { ...Tooltip.DefaultType, content: '(string|element|function)' }; const Event$1 = {
  HIDE: 'hide.bs.popover', HIDDEN: 'hidden.bs.popover', SHOW: 'show.bs.popover', SHOWN: 'shown.bs.popover', INSERTED: 'inserted.bs.popover', CLICK: 'click.bs.popover', FOCUSIN: 'focusin.bs.popover', FOCUSOUT: 'focusout.bs.popover', MOUSEENTER: 'mouseenter.bs.popover', MOUSELEAVE: 'mouseleave.bs.popover',
}; const CLASS_NAME_FADE$2 = 'fade'; const CLASS_NAME_SHOW$2 = 'show'; const SELECTOR_TITLE = '.popover-header'; const SELECTOR_CONTENT = '.popover-body'; class Popover extends Tooltip {
  static get Default() { return Default$2; }

  static get NAME() { return NAME$3; }

  static get Event() { return Event$1; }

  static get DefaultType() { return DefaultType$2; }

  isWithContent() { return this.getTitle() || this._getContent(); }

  getTipElement() { return this.tip || (this.tip = super.getTipElement(), this.getTitle() || SelectorEngine.findOne(SELECTOR_TITLE, this.tip).remove(), this._getContent() || SelectorEngine.findOne('.popover-body', this.tip).remove()), this.tip; }

  setContent() { const e = this.getTipElement(); this.setElementContent(SelectorEngine.findOne(SELECTOR_TITLE, e), this.getTitle()); let t = this._getContent(); typeof t === 'function' && (t = t.call(this._element)), this.setElementContent(SelectorEngine.findOne('.popover-body', e), t), e.classList.remove('fade', 'show'); }

  _addAttachmentClass(e) { this.getTipElement().classList.add(`bs-popover-${this.updateAttachment(e)}`); }

  _getContent() { return this._element.getAttribute('data-bs-content') || this._config.content; }

  _cleanTipClass() { const e = this.getTipElement(); const t = e.getAttribute('class').match(BSCLS_PREFIX_REGEX); t !== null && t.length > 0 && t.map((e) => e.trim()).forEach((t) => e.classList.remove(t)); }

  static jQueryInterface(e) { return this.each((function () { const t = Popover.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } })); }
}defineJQueryPlugin(Popover); const NAME$2 = 'scrollspy'; const DATA_KEY$2 = 'bs.scrollspy'; const EVENT_KEY$2 = '.bs.scrollspy'; const DATA_API_KEY$1 = '.data-api'; const Default$1 = { offset: 10, method: 'auto', target: '' }; const DefaultType$1 = { offset: 'number', method: 'string', target: '(string|element)' }; const EVENT_ACTIVATE = 'activate.bs.scrollspy'; const EVENT_SCROLL = 'scroll.bs.scrollspy'; const EVENT_LOAD_DATA_API = 'load.bs.scrollspy.data-api'; const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item'; const CLASS_NAME_ACTIVE$1 = 'active'; const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]'; const SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group'; const SELECTOR_NAV_LINKS = '.nav-link'; const SELECTOR_NAV_ITEMS = '.nav-item'; const SELECTOR_LIST_ITEMS = '.list-group-item'; const SELECTOR_DROPDOWN$1 = '.dropdown'; const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle'; const METHOD_OFFSET = 'offset'; const METHOD_POSITION = 'position'; class ScrollSpy extends BaseComponent {
  constructor(e, t) { super(e), this._scrollElement = this._element.tagName === 'BODY' ? window : this._element, this._config = this._getConfig(t), this._selector = `${this._config.target} .nav-link, ${this._config.target} .list-group-item, ${this._config.target} .dropdown-item`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process()), this.refresh(), this._process(); }

  static get Default() { return Default$1; }

  static get NAME() { return NAME$2; }

  refresh() {
    const e = this._scrollElement === this._scrollElement.window ? 'offset' : 'position'; const t = this._config.method === 'auto' ? e : this._config.method; const n = t === 'position' ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), SelectorEngine.find(this._selector).map((e) => { const i = getSelectorFromElement(e); const s = i ? SelectorEngine.findOne(i) : null; if (s) { const e = s.getBoundingClientRect(); if (e.width || e.height) return [Manipulator[t](s).top + n, i]; } return null; }).filter((e) => e).sort((e, t) => e[0] - t[0])
      .forEach((e) => { this._offsets.push(e[0]), this._targets.push(e[1]); });
  }

  dispose() { EventHandler.off(this._scrollElement, EVENT_KEY$2), super.dispose(); }

  _getConfig(e) { if (typeof (e = { ...Default$1, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' && e ? e : {} }).target !== 'string' && isElement(e.target)) { let{ id: t } = e.target; t || (t = getUID(NAME$2), e.target.id = t), e.target = `#${t}`; } return typeCheckConfig(NAME$2, e, DefaultType$1), e; }

  _getScrollTop() { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop; }

  _getScrollHeight() { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight); }

  _getOffsetHeight() { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height; }

  _process() { const e = this._getScrollTop() + this._config.offset; const t = this._getScrollHeight(); const n = this._config.offset + t - this._getOffsetHeight(); if (this._scrollHeight !== t && this.refresh(), e >= n) { const e = this._targets[this._targets.length - 1]; this._activeTarget !== e && this._activate(e); } else { if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let t = this._offsets.length; t--;) this._activeTarget !== this._targets[t] && e >= this._offsets[t] && (void 0 === this._offsets[t + 1] || e < this._offsets[t + 1]) && this._activate(this._targets[t]); } }

  _activate(e) { this._activeTarget = e, this._clear(); const t = this._selector.split(',').map((t) => `${t}[data-bs-target="${e}"],${t}[href="${e}"]`); const n = SelectorEngine.findOne(t.join(',')); n.classList.contains('dropdown-item') ? (SelectorEngine.findOne('.dropdown-toggle', n.closest('.dropdown')).classList.add('active'), n.classList.add('active')) : (n.classList.add('active'), SelectorEngine.parents(n, '.nav, .list-group').forEach((e) => { SelectorEngine.prev(e, '.nav-link, .list-group-item').forEach((e) => e.classList.add('active')), SelectorEngine.prev(e, '.nav-item').forEach((e) => { SelectorEngine.children(e, '.nav-link').forEach((e) => e.classList.add('active')); }); })), EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, { relatedTarget: e }); }

  _clear() { SelectorEngine.find(this._selector).filter((e) => e.classList.contains('active')).forEach((e) => e.classList.remove('active')); }

  static jQueryInterface(e) { return this.each((function () { const t = ScrollSpy.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } })); }
}EventHandler.on(window, EVENT_LOAD_DATA_API, () => { SelectorEngine.find(SELECTOR_DATA_SPY).forEach((e) => new ScrollSpy(e)); }), defineJQueryPlugin(ScrollSpy); const NAME$1 = 'tab'; const DATA_KEY$1 = 'bs.tab'; const EVENT_KEY$1 = '.bs.tab'; const DATA_API_KEY = '.data-api'; const EVENT_HIDE$1 = 'hide.bs.tab'; const EVENT_HIDDEN$1 = 'hidden.bs.tab'; const EVENT_SHOW$1 = 'show.bs.tab'; const EVENT_SHOWN$1 = 'shown.bs.tab'; const EVENT_CLICK_DATA_API = 'click.bs.tab.data-api'; const CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu'; const CLASS_NAME_ACTIVE = 'active'; const CLASS_NAME_FADE$1 = 'fade'; const CLASS_NAME_SHOW$1 = 'show'; const SELECTOR_DROPDOWN = '.dropdown'; const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group'; const SELECTOR_ACTIVE = '.active'; const SELECTOR_ACTIVE_UL = ':scope > li > .active'; const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle'; const SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active'; class Tab extends BaseComponent {
  static get NAME() { return 'tab'; }

  show() { if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains('active')) return; let e; const t = getElementFromSelector(this._element); const n = this._element.closest('.nav, .list-group'); if (n) { const t = n.nodeName === 'UL' || n.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : '.active'; e = SelectorEngine.find(t, n), e = e[e.length - 1]; } const i = e ? EventHandler.trigger(e, EVENT_HIDE$1, { relatedTarget: this._element }) : null; if (EventHandler.trigger(this._element, EVENT_SHOW$1, { relatedTarget: e }).defaultPrevented || i !== null && i.defaultPrevented) return; this._activate(this._element, n); const s = () => { EventHandler.trigger(e, EVENT_HIDDEN$1, { relatedTarget: this._element }), EventHandler.trigger(this._element, EVENT_SHOWN$1, { relatedTarget: e }); }; t ? this._activate(t, t.parentNode, s) : s(); }

  _activate(e, t, n) { const i = (!t || t.nodeName !== 'UL' && t.nodeName !== 'OL' ? SelectorEngine.children(t, '.active') : SelectorEngine.find(SELECTOR_ACTIVE_UL, t))[0]; const s = n && i && i.classList.contains('fade'); const o = () => this._transitionComplete(e, i, n); i && s ? (i.classList.remove('show'), this._queueCallback(o, e, !0)) : o(); }

  _transitionComplete(e, t, n) { if (t) { t.classList.remove('active'); const e = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, t.parentNode); e && e.classList.remove('active'), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !1); }e.classList.add('active'), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !0), reflow(e), e.classList.contains('fade') && e.classList.add('show'); let i = e.parentNode; if (i && i.nodeName === 'LI' && (i = i.parentNode), i && i.classList.contains('dropdown-menu')) { const t = e.closest('.dropdown'); t && SelectorEngine.find('.dropdown-toggle', t).forEach((e) => e.classList.add('active')), e.setAttribute('aria-expanded', !0); }n && n(); }

  static jQueryInterface(e) { return this.each((function () { const t = Tab.getOrCreateInstance(this); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } })); }
}EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, (function (e) { ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), isDisabled(this) || Tab.getOrCreateInstance(this).show(); })), defineJQueryPlugin(Tab); const NAME = 'toast'; const DATA_KEY = 'bs.toast'; const EVENT_KEY = '.bs.toast'; const EVENT_CLICK_DISMISS = 'click.dismiss.bs.toast'; const EVENT_MOUSEOVER = 'mouseover.bs.toast'; const EVENT_MOUSEOUT = 'mouseout.bs.toast'; const EVENT_FOCUSIN = 'focusin.bs.toast'; const EVENT_FOCUSOUT = 'focusout.bs.toast'; const EVENT_HIDE = 'hide.bs.toast'; const EVENT_HIDDEN = 'hidden.bs.toast'; const EVENT_SHOW = 'show.bs.toast'; const EVENT_SHOWN = 'shown.bs.toast'; const CLASS_NAME_FADE = 'fade'; const CLASS_NAME_HIDE = 'hide'; const CLASS_NAME_SHOW = 'show'; const CLASS_NAME_SHOWING = 'showing'; const DefaultType = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const Default = { animation: !0, autohide: !0, delay: 5e3 }; const SELECTOR_DATA_DISMISS = '[data-bs-dismiss="toast"]'; class Toast extends BaseComponent {
  constructor(e, t) { super(e), this._config = this._getConfig(t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(); }

  static get DefaultType() { return DefaultType; }

  static get Default() { return Default; }

  static get NAME() { return NAME; }

  show() { EventHandler.trigger(this._element, EVENT_SHOW).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add('fade'), this._element.classList.remove('hide'), reflow(this._element), this._element.classList.add('showing'), this._queueCallback(() => { this._element.classList.remove('showing'), this._element.classList.add('show'), EventHandler.trigger(this._element, EVENT_SHOWN), this._maybeScheduleHide(); }, this._element, this._config.animation)); }

  hide() { this._element.classList.contains('show') && (EventHandler.trigger(this._element, EVENT_HIDE).defaultPrevented || (this._element.classList.remove('show'), this._queueCallback(() => { this._element.classList.add('hide'), EventHandler.trigger(this._element, EVENT_HIDDEN); }, this._element, this._config.animation))); }

  dispose() { this._clearTimeout(), this._element.classList.contains('show') && this._element.classList.remove('show'), super.dispose(); }

  _getConfig(e) { return e = { ...Default, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' && e ? e : {} }, typeCheckConfig(NAME, e, this.constructor.DefaultType), e; }

  _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide(); }, this._config.delay))); }

  _onInteraction(e, t) { switch (e.type) { case 'mouseover': case 'mouseout': this._hasMouseInteraction = t; break; case 'focusin': case 'focusout': this._hasKeyboardInteraction = t; } if (t) return void this._clearTimeout(); const n = e.relatedTarget; this._element === n || this._element.contains(n) || this._maybeScheduleHide(); }

  _setListeners() { EventHandler.on(this._element, EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, () => this.hide()), EventHandler.on(this._element, EVENT_MOUSEOVER, (e) => this._onInteraction(e, !0)), EventHandler.on(this._element, EVENT_MOUSEOUT, (e) => this._onInteraction(e, !1)), EventHandler.on(this._element, EVENT_FOCUSIN, (e) => this._onInteraction(e, !0)), EventHandler.on(this._element, EVENT_FOCUSOUT, (e) => this._onInteraction(e, !1)); }

  _clearTimeout() { clearTimeout(this._timeout), this._timeout = null; }

  static jQueryInterface(e) { return this.each((function () { const t = Toast.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](this); } })); }
}defineJQueryPlugin(Toast); export {
  Alert, Button, Carousel, Collapse, Dropdown, Modal, Offcanvas, Popover, ScrollSpy, Tab, Toast, Tooltip,
};
// # sourceMappingURL=bootstrap.esm.min.js.map